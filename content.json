{"meta":{"title":"archlinux6","subtitle":"","description":"学习笔记","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"高数笔记","slug":"高数笔记","date":"2023-11-10T12:07:35.000Z","updated":"2023-11-15T08:29:43.947Z","comments":false,"path":"2023/11/10/高数笔记/","link":"","permalink":"http://example.com/2023/11/10/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/","excerpt":"高数笔记","text":"高数笔记 做题技巧 x^n n趋向无穷时，得看x的取值范围当x&gt;&#x3D;1时，x^n趋向无穷，当0&lt;&#x3D;x&lt;&#x3D;1时，x^n趋向0 25&#x2F;25&#x2F;5不能看成 25&#x2F;5 &#x3D; 5而是1&#x2F;5 命题组经常默认 n为自然数，如果没有定义，默认自然数。 一阶递推式 二阶递推式 二项式定理 n次方差公式 极限函数极限等阶无穷小是特殊的同阶无穷小小o 表示 高阶无穷小大O 表示 同阶，同数量级 极限四则运算法则 注意要极限存在的前提 洛必达法则 注意洛必达使用的第二点条件 lim ?&#x2F;0 极限存放的情况 错题，错误地对分子使用洛必达，求f(1) &#x3D; -2的导数为0，分母为1，结果为0结果应该为f’(x) 最后再把1带进去，把f(x)看成含有x的表达式 利用函数周期性解决问题sinx 是周期函数结合图像来理解 sin(2n派 + x) &#x3D; sin xsin(n派 + x) &#x3D; (-1)^n * sinx目前还没理解为什么不能用这种方法，可能是由于极限四则运算前提条件 极限存在不成立 数列极限数列极限存在证明数列极限存在 需要用 单调有界定理 先证明其单调性，对于任意的n, 有 Xn &gt;= Xn+1 或者 Xn &lt;= Xn+1 证明其有界性，对于任意的n, 有 m &lt; Xn &lt; M 常用第一数学归纳法证明，证明X1对于命题成立，再假设Xk成立， 证明Xk+1成立，则命题对于一切的n成立。 - 证明其单调性，对于任意的n, 有 Xn &gt;= Xn+1 或者 Xn &lt;= Xn+1 可以先证明 X1 &gt;= X2 或者 X1 &lt;= X2 假设Xk &gt;= Xk+1 或者 Xk &lt;= Xk+1 借助假设条件 证明Xk+1 &gt;= Xk+2 或者 Xk+1 &lt;= Xk+2 - 证明其有界性，对于任意的n, 有 m &lt; Xn &lt; M 证完单调性再证有界性只需证明有上界或有下界 用数学归纳法证明 证明X1 &gt;= m 或者 X1 &lt;= M 假设Xk &gt;= m 或者 Xk &lt;= M 证明Xk+1 &gt;= m 或者 Xk+1 &lt;= M 注意，结合图像记忆 y1 = sinx , y2 = x 当x &lt; 0, sinx &gt; x 当x = 0, sinx = x 当x &gt; 0, sinx &lt; x 当0 &lt;= x &lt;= 1, 0 &lt;= sinx &lt;= x &lt;= 1 综上 证明数列单调减且有下界 证明数列单调增且有上界 连续 间断连续函数连续函数（continuous function）上处处连续，每点的极限值等于函数值 连续函数的复合函数依旧是连续函数。连续函数运算法则，连续函数的四则运算结果为连续函数 举反例常用：狄利克雷函数 处处不连续 无法画出函数图像，但是它的函数图像客观存在 分段函数的间断点分段函数的间断点：除了每一段函数的间断点，另外检验分界点，可能出现： 分界点极限不相等； 分界点的值无定义； 分界点的值有定义但不等于左、右极限。 导数 导数 导函数 函数某点的导数是 与自变量对应的因变量的值 比上 自变量变化了很小的值 的值 可以理解成是它的斜率，k &#x3D; tanx &#x3D; 对边 比上 邻边, 也可以理解成某点的瞬时速度 注意某点可导隐含着连续 导数定义 注意其三个不同形式的公式 dertax的任意性 只要dertax和另一个变形都是趋于0的即可 导数四则运算 除法可以看做乘法去算，注意第五点，容易少计算分子的v',根据复合函数求导链式法则 参数方程的二阶导 求某点的一阶导，二阶导，先把导数求出来，最后再把某点代进去算。 隐函数求导y &#x3D; 2x 是显函数2x - y &#x3D; 0 是隐函数不能直接看出由x表示出来的y的函数是隐函数求导方法：方程两边同时对x求导，y看成x的复合函数注意 (y^2)’ &#x3D; 2y * y’ 绝对值函数在零点可导的充要条件 绝对值函数|x|可以用来证明连续不一定可导 |f(x)| 是绝对值函数, 绝对值是连续的，连续不一定可导 零点（zero point）对于函数y&#x3D;f(x)，使f(x)&#x3D;0的实数x叫做函数y&#x3D;f(x)的零点，即零点不是点。函数y&#x3D;f(x)的零点就是方程f(x)&#x3D;0的实数根，也就是函数y&#x3D;f(x)的图象与x轴的交点的横坐标。一句话，令f(x)&#x3D;0的x即是零点 含绝对值的两函数之积在绝对值零点可导的充要条件 积分变限积分F(t) &#x3D; 积分号 f(t)dt","categories":[],"tags":[]},{"title":"线性代数","slug":"线性代数","date":"2023-11-10T10:45:02.000Z","updated":"2023-11-15T08:04:33.247Z","comments":false,"path":"2023/11/10/线性代数/","link":"","permalink":"http://example.com/2023/11/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"线性代数学习笔记","text":"线性代数学习笔记 行列式克拉默法则 线性方程组齐次和非齐次Ax=0 齐次线性方程组 Ax=b 非齐次线性方程组 [A]是系数矩阵，[A|b]是增广矩阵 向量形式是矩阵A的列向量组和向量的乘积。 对增广矩阵进行初等行变换，整体化成行阶梯形, [ | ] 左边是r(A),右边是r(A|b) 秩和方程解的情况 基础解系个数为n-r(矩阵) 通解是这个方程所有解的集合，也叫作解集。特解是这个方程的所有解当中的某一个，也就是解集中的某一个元素。","categories":[],"tags":[]},{"title":"算法笔记","slug":"算法笔记","date":"2023-10-01T15:17:15.000Z","updated":"2023-11-10T11:31:50.465Z","comments":false,"path":"2023/10/01/算法笔记/","link":"","permalink":"http://example.com/2023/10/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"算法学习笔记","text":"算法学习笔记 C++笔记1. C++ 语言源文件扩展名为 .cpp 2. #include &lt;cstdio&gt; 等价于 #include &lt;stdio.h&gt; 3. \\t Tab键作用 \\n 换行 \\0 NULL,ASCII = 0 3. BOOL 非零： true 零：false 5.强制类型转换：(新类型名)变量名 6.定义常量 const 数据类型 变量名 = 常量; 4. if(n) 等价于 if(n != 0) if(!n) 等价于 if(n == 0) 5. memset 对数组中每一个元素赋相同的值 memset (数组名,值,sizeof(数组名)) 求最大公约数方法 （两个不全为0 的非负整数）辗转相除，相减，减一最大公约数 * 最小公倍数 &#x3D; 两数之积0 8 最大公约数是 8欧几里得算法时空复杂度都是O(logn) set 和 mapset 自动去重和自动按数字升序排列multiset 允许 重复的和自动按数字升序排列unordered_set 去重和无序 （基于哈希表 ）都用insert()插入元素, find()方法返回一个迭代器，表示找到的元素的位置，如果未找到则返回end()迭代器。应该使用sets.find(num) &#x3D;&#x3D; sets.end()来判断是否未找到元素。s[i] 不能随机访问其中元素，*s.rbegin()可以访问最后一个元素，即最大值map 键去重和自动按数字升序排列unordered_map 去重和无序 （基于哈希表 ） 约数对于一个正整数，其约数的个数可以通过将其进行质因数分解，并将各个质因数的指数加一后相乘得到。 丑数任何一个丑数都可以由另一个较小的丑数乘以2、3或5得到。 快排代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;// 快速排序函数void quickSort(int arr[], int low, int high) &#123; if (low &lt; high) &#123; int pivot = arr[low]; // 将第一个元素作为基准数 int i = low, j = high; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123; j--; &#125; if (i &lt; j) &#123; arr[i++] = arr[j]; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; &#125; if (i &lt; j) &#123; arr[j--] = arr[i]; &#125; &#125; arr[i] = pivot; // 基准数放到中间位置 quickSort(arr, low, i - 1); // 左侧递归排序 quickSort(arr, i + 1, high); // 右侧递归排序 &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; quickSort(arr, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"机器学习","slug":"机器学习","date":"2023-09-23T08:15:41.000Z","updated":"2023-09-24T13:09:04.972Z","comments":false,"path":"2023/09/23/机器学习/","link":"","permalink":"http://example.com/2023/09/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"机器学习笔记","text":"机器学习笔记 py1.注意和js一样不用加分号不用加变量定义不用加数据类型 2.定义一个函数 def 函数名（参数列表）: 函数体 3.if用法 if 判断条件： 执行语句…… else： 执行语句…… 4.print print()打印 机器学习import 导入，进口，几个package, as 后跟着别名1.numpy 用来实现向量，矩阵计算2.padas 用来导入csv文件 padas.read_csv(&#39;./文件名.csv&#39;) 或者 padas.read_csv(&#39;文件名.csv&#39;) 文件名.csv和当前程序放在一起3.matplotlib 用来实现数据可视化 plt是别名plt.scatter(x,y) 散播图plt.show() 放出图 4.sklearn 里有数据集 dataset from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn import linear_model 5.数据集分为训练集和测试集，一条数据分为特征值和目标值6.任务分回归和分类，根据目标值是连续值还是离散值来判断7.第一个机器学习算法是线性回归算法","categories":[],"tags":[]}],"categories":[],"tags":[]}