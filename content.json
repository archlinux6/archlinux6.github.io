{"meta":{"title":"archlinux6","subtitle":"","description":"学习笔记","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"英语笔记","slug":"英语笔记","date":"2023-11-17T11:30:25.000Z","updated":"2023-11-22T09:04:11.462Z","comments":false,"path":"2023/11/17/英语笔记/","link":"","permalink":"http://example.com/2023/11/17/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/","excerpt":"英语学习笔记","text":"英语学习笔记 意义相似词汇heap pile 堆 educate foster cultivate nurture 培育 keep maintain sustain 维持 engage participate 参加 participant 参与者 shortcoming defect weakness 缺点 demerit stable steady 稳定的 likelihood probability possibility 可能性 prospect 外形相似词汇oral 口的 moral 道德的 personal 私人的 personality 性格 character precious valuable 珍贵的 previous 先前的 former prior psychology 心理学 psychological physical physics culture cultural be accustomed to / be used to 习惯于 accumulate 积累 accelerate 加速 重要词组in no way in no case on no account by no means 绝不 by accident by chance 突然，偶然 occasional 偶然，突然 take…into account/consideration 把..考虑进去­ on account of because of for the sake of 因为 due to a sequence of 一系列 a series of","categories":[],"tags":[]},{"title":"高数笔记","slug":"高数笔记","date":"2023-11-10T12:07:35.000Z","updated":"2023-11-21T15:53:27.155Z","comments":false,"path":"2023/11/10/高数笔记/","link":"","permalink":"http://example.com/2023/11/10/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/","excerpt":"高数学习笔记","text":"高数学习笔记 做题技巧 x^n n趋向无穷时，得看x的取值范围当x&gt;&#x3D;1时，x^n趋向无穷，当0&lt;&#x3D;x&lt;&#x3D;1时，x^n趋向0 25&#x2F;25&#x2F;5不能看成 25&#x2F;5 &#x3D; 5而是1&#x2F;5a&#x2F;b&#x3D; c&#x2F;dad &#x3D; bc 乘除转换a&#x2F;b &#x3D; a * 1&#x2F;b 命题组经常默认 n为自然数，如果没有定义，默认自然数。 一阶递推式 二阶递推式 二项式定理 n次方差公式 反函数y &#x3D; tan x &#x3D; 对边比邻边&#x3D; sinx &#x2F; cosx (cos x !&#x3D; 0,x !&#x3D; pai &#x2F; 2 + k * pai, k 属于 Z)arctan y &#x3D; xy &#x3D; arctan x 反函数求法用y来表示x值域和定义域互换 等式两边都有绝对值一共有四种情况a &#x3D; b &gt; 0a &#x3D; b &lt; 0a &gt; 0, b &lt; 0, a &#x3D; -ba &lt; 0, b &gt; 0, a &#x3D; -b 注：七月份刚学的时候被困惑到 极限极限性质保号性函数极限等阶无穷小是特殊的同阶无穷小小o 表示 高阶无穷小大O 表示 同阶，同数量级 极限四则运算法则 注意要极限存在的前提 极限存在情况两个极限 f(x) g(x)f(x)极限存在，g(x)极限存在， f(x)+-g(x)极限存在f(x)极限不存在，g(x)极限存在， f(x)+-g(x)极限不存在f(x)极限存在，g(x)极限不存在， f(x)+-g(x)极限不存在f(x)极限不存在，g(x)极限不存在，f(x)+-g(x)极限可能存在，但不能同时存在 洛必达法则 注意洛必达使用的第二点条件 lim ?&#x2F;0 极限存放的情况 错题，错误地对分子使用洛必达，求f(1) &#x3D; -2的导数为0，分母为1，结果为0结果应该为f’(x) 最后再把1带进去，把f(x)看成含有x的表达式 利用函数周期性解决问题sinx 是周期函数结合图像来理解 sin(2n派 + x) &#x3D; sin xsin(n派 + x) &#x3D; (-1)^n * sinx目前还没理解为什么不能用这种方法，可能是由于极限四则运算前提条件 极限存在不成立 数列极限数列极限存在证明数列极限存在 需要用 单调有界定理 先证明其单调性，对于任意的n, 有 Xn &gt;= Xn+1 或者 Xn &lt;= Xn+1 证明其有界性，对于任意的n, 有 m &lt; Xn &lt; M 常用第一数学归纳法证明，证明X1对于命题成立，再假设Xk成立， 证明Xk+1成立，则命题对于一切的n成立。 - 证明其单调性，对于任意的n, 有 Xn &gt;= Xn+1 或者 Xn &lt;= Xn+1 可以先证明 X1 &gt;= X2 或者 X1 &lt;= X2 假设Xk &gt;= Xk+1 或者 Xk &lt;= Xk+1 借助假设条件 证明Xk+1 &gt;= Xk+2 或者 Xk+1 &lt;= Xk+2 - 证明其有界性，对于任意的n, 有 m &lt; Xn &lt; M 证完单调性再证有界性只需证明有上界或有下界 用数学归纳法证明 证明X1 &gt;= m 或者 X1 &lt;= M 假设Xk &gt;= m 或者 Xk &lt;= M 证明Xk+1 &gt;= m 或者 Xk+1 &lt;= M 注意，结合图像记忆 y1 = sinx , y2 = x 当x &lt; 0, sinx &gt; x 当x = 0, sinx = x 当x &gt; 0, sinx &lt; x 当0 &lt;= x &lt;= 1, 0 &lt;= sinx &lt;= x &lt;= 1 综上 证明数列单调减且有下界 证明数列单调增且有上界 连续 间断连续函数连续函数（continuous function）上处处连续，每点的极限值等于函数值 连续函数的复合函数依旧是连续函数。连续函数运算法则，连续函数的四则运算结果为连续函数 举反例常用：狄利克雷函数 处处不连续 无法画出函数图像，但是它的函数图像客观存在 分段函数的间断点分段函数的间断点：除了每一段函数的间断点，另外检验分界点，可能出现： 分界点极限不相等； 分界点的值无定义； 分界点的值有定义但不等于左、右极限。 导数 导数 导函数 函数某点的导数是 与自变量对应的因变量的值 比上 自变量变化了很小的值 的值 可以理解成是它的斜率，k &#x3D; tanx &#x3D; 对边 比上 邻边, 也可以理解成某点的瞬时速度 注意某点可导隐含着连续 导数定义 注意其三个不同形式的公式 dertax的任意性 只要dertax和另一个变形都是趋于0的即可 只有单边导数存在 导数四则运算除法可以看做乘法去算，注意第五点，容易少计算分子的v’,根据复合函数求导链式法则 参数方程的二阶导 求某点的一阶导，二阶导，先把导数求出来，最后再把某点代进去算。 隐函数求导y &#x3D; 2x 是显函数2x - y &#x3D; 0 是隐函数不能直接看出由x表示出来的y的函数是隐函数求导方法：方程两边同时对x求导，y看成x的复合函数注意 (y^2)’ &#x3D; 2y * y’ 绝对值函数在零点可导的充要条件 绝对值函数|x|可以用来证明连续不一定可导 |f(x)| 是绝对值函数, 绝对值是连续的，连续不一定可导 零点（zero point）对于函数y&#x3D;f(x)，使f(x)&#x3D;0的实数x叫做函数y&#x3D;f(x)的零点，即零点不是点。函数y&#x3D;f(x)的零点就是方程f(x)&#x3D;0的实数根，也就是函数y&#x3D;f(x)的图象与x轴的交点的横坐标。一句话，令f(x)&#x3D;0的x即是零点 含绝对值的两函数之积在绝对值零点可导的充要条件 积分变限积分F(t) &#x3D; 积分号 f(t)dt 微分方程函数方程是含有自变量和因变量的方程主要研究的是常微分方程常微分方程是含有一个自变量，一个函数的微分方程含有导数或者微分的方程是微分方程微分方程的解是一个函数y","categories":[],"tags":[]},{"title":"线性代数","slug":"线性代数","date":"2023-11-10T10:45:02.000Z","updated":"2023-11-21T13:13:38.577Z","comments":false,"path":"2023/11/10/线性代数/","link":"","permalink":"http://example.com/2023/11/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"线性代数学习笔记Linear Algebra几何直观","text":"线性代数学习笔记Linear Algebra几何直观 向量关键点标量是只有大小的量，如数字，向量是既有大小也有方向的量，长度表示大小，箭头表示方向； 向量的核心运算 是向量加法运算和数乘向量运算 向量的起点都放在原点上 两个数乘向量的和为这两个向量的线性组合 所有线性组合组成的向量集合为这两个向量的张成的空间 向量的加法运算，移动一个向量的起点到另一个向量的终点上，然后连接原点和终点，此为向量的加法运算的结果 向量的坐标(3,2)可以理解为 3*i + 2*j 线性方程组齐次和非齐次Ax=0 齐次线性方程组 Ax=b 非齐次线性方程组 [A]是系数矩阵，[A|b]是增广矩阵 向量形式是矩阵A的列向量组和向量的乘积。 对增广矩阵进行初等行变换，整体化成行阶梯形, [ | ] 左边是r(A),右边是r(A|b) 秩和方程解的情况 齐次线性方程组 解的性质 基础解系个数为n-r(矩阵) 用基础解系来表示无穷多解 非齐次线性方程组的通解的求法 通解是这个方程所有解的集合，也叫作解集，含有变量。特解是这个方程的所有解当中的某一个，也就是解集中的某一个元素，不含有变量。 行列式一阶行列式 |a| &#x3D; a解方程组可以使用高斯消元法也可以使用克拉默法则 克拉默法则 矩阵实数包含有理数和无理数常数是值不变的数 初等矩阵的逆矩阵单位矩阵它是个方阵，主对角线上的元素均为1，除此以外全都为0。由单位矩阵经过一次初等变换得到的矩阵称为初等矩阵 初等行变换： ① 行和行的变换（对换变换） ② 行×常数的变换（倍乘变换） ③ 行×常数再加另一行的变换（倍加变换） 初等矩阵的性质 左行右列定理对n阶矩阵A进行初等行变换，相当于矩阵A左乘相应的初等矩阵 同样，对A进行初等列变换，相当于矩阵A右乘相应的初等矩阵 特征值和特征向量n阶矩阵含有n个特征值（包含重数）特征值相加 &#x3D; tr(矩阵)特征值相乘 &#x3D; |矩阵|实数包含有理数和无理数 x是对应于（属于）特征值的特征向量 对角化 相似性质 ： 秩相等，特征方程相等，行列式相等","categories":[],"tags":[]},{"title":"算法笔记","slug":"算法笔记","date":"2023-10-01T15:17:15.000Z","updated":"2023-11-19T10:17:15.693Z","comments":false,"path":"2023/10/01/算法笔记/","link":"","permalink":"http://example.com/2023/10/01/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"算法学习笔记","text":"算法学习笔记 C++笔记语法1. C++ 语言源文件扩展名为 .cpp 2. #include &lt;cstdio&gt; 等价于 #include &lt;stdio.h&gt; 万能C++头文件名 #include &lt;bits/stdc++.h&gt; 3. \\t Tab键作用 \\n 换行 \\0 NULL,ASCII = 0 4. BOOL 非零： true 零：false 5.强制类型转换：(新类型名)变量名 6.定义常量 const 数据类型 变量名 = 常量; 5. if(n) 等价于 if(n != 0) if(!n) 等价于 if(n == 0) 6. memset 对数组中每一个元素赋相同的值 memset (数组名,值,sizeof(数组名)) 7. #define MAX 100 typedef 8. new STL INT32_MAX ,INT32_MIN,C++中常量分别表示最大、最小整数 set 和 map set 自动去重和自动按数字升序排列 multiset 允许 重复的和自动按数字升序排列 unordered_set 去重和无序 （基于哈希表 ） 都用insert()插入元素, find()方法返回一个迭代器，表示找到的元素的位置，如果未找到则返回end()迭代器。应该使用sets.find(num) == sets.end()来判断是否未找到元素。 sets[i] 不能随机访问其中元素，*sets.rbegin()可以访问最后一个元素，即最大值 map 键去重和自动按数字升序排列 unordered_map 去重和无序 （基于哈希表 ） vector 动态数组 vector&lt;int&gt; array(n, 1); 创建一个包含 n 个元素的整数数组，并将每个元素初始化为 1。 数据结构笔记并查集算法分析伪代码 算法描述语言语句结束不用加分号 变量不用定义 不用加括号 &lt;- 赋值 mod 模除 for i &lt;- 0 to n - 1 do i 从 0 遍历到 n - 1 欧几里得伪代码 渐近符号 T( n ) T 理解成time ，表示算法的运行时间 n 是问题规模 f(n) f为frequency 频率，次数， 表示基本语句执行次数 参考：算法导论——渐近记号Θ、Ο、o、Ω、ω详解 主定理向下取整的运算用数学符号⌊ ⌋表示；向上取整的运算用数学符号⌈ ⌉表示。 给定 4.9调用向下取整函数 得到的是 4调用向上取整函数 得到的是 5 向上取整：比自己大的最小整数；向下取整：比自己小的最大整数； 递归动态规划回溯素数问题求最大公约数方法 （两个不全为0 的非负整数）方法： 辗转相除法（欧几里得算法，世界上最古老的算法），辗转相减法，连续整数检测法 最大公约数 * 最小公倍数 = 两数之积 0 8 最大公约数是 8 欧几里得算法时空复杂度都是O(logn) 其他数 约数个数定理对于一个正整数，其约数的个数可以通过将其进行质因数分解，并将各个质因数的指数加一后相乘得到。 丑数丑数是指不能被2，3，5以外的其他素数整除的数。把丑数从小到大排列起来，结果如下： 1,2,3,4,5,6,8,9,10,12,15……任何一个丑数都可以由另一个较小的丑数乘以2、3或5得到。 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;// 快速排序函数void quickSort(int arr[], int low, int high) &#123; if (low &lt; high) &#123; int pivot = arr[low]; // 将第一个元素作为基准数 int i = low, j = high; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123; j--; &#125; if (i &lt; j) &#123; arr[i++] = arr[j]; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; &#125; if (i &lt; j) &#123; arr[j--] = arr[i]; &#125; &#125; arr[i] = pivot; // 基准数放到中间位置 quickSort(arr, low, i - 1); // 左侧递归排序 quickSort(arr, i + 1, high); // 右侧递归排序 &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; quickSort(arr, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 合并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 合并两个有序子数组为一个有序数组void merge(vector&lt;int&gt;&amp; arr, int l, int m, int r) &#123; vector&lt;int&gt; merged; int i = l, j = m + 1; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (arr[i] &lt;= arr[j]) &#123; merged.push_back(arr[i]); i++; &#125; else &#123; merged.push_back(arr[j]); j++; &#125; &#125; while (i &lt;= m) &#123; merged.push_back(arr[i]); i++; &#125; while (j &lt;= r) &#123; merged.push_back(arr[j]); j++; &#125; for (int k = l; k &lt;= r; k++) &#123; arr[k] = merged[k - l]; &#125;&#125;// 递归地将数组分成两半，分别进行排序和合并void mergeSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123; if (l &lt; r) &#123; int m = l + (r - l) / 2; mergeSort(arr, l, m); mergeSort(arr, m + 1, r); merge(arr, l, m, r); &#125;&#125;int main() &#123; int n = 6; vector&lt;int&gt; arr(n, 0); cout &lt;&lt; &quot;给定数组是：&quot; &lt;&lt; endl; for (int i = 0; i &lt; arr.size(); i++) &#123; cin &gt;&gt; arr[i]; &#125; cout &lt;&lt; endl; mergeSort(arr, 0, arr.size() - 1); cout &lt;&lt; &quot;排序后的数组是：&quot; &lt;&lt; endl; for (int i = 0; i &lt; arr.size(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"机器学习","slug":"机器学习","date":"2023-09-23T08:15:41.000Z","updated":"2023-11-17T11:31:49.111Z","comments":false,"path":"2023/09/23/机器学习/","link":"","permalink":"http://example.com/2023/09/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"机器学习笔记","text":"机器学习笔记 py1.注意和js一样不用加分号不用加变量定义不用加数据类型 2.定义一个函数 def 函数名（参数列表）: 函数体 3.if用法 if 判断条件： 执行语句…… else： 执行语句…… 4.print print()打印 机器学习import 导入，进口，几个package, as 后跟着别名1.numpy 用来实现向量，矩阵计算2.padas 用来导入csv文件 padas.read_csv(&#39;./文件名.csv&#39;) 或者 padas.read_csv(&#39;文件名.csv&#39;) 文件名.csv和当前程序放在一起3.matplotlib 用来实现数据可视化 plt是别名plt.scatter(x,y) 散播图plt.show() 放出图 4.sklearn 里有数据集 dataset from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn import linear_model 5.数据集分为训练集和测试集，一条数据分为特征值和目标值6.任务分回归和分类，根据目标值是连续值还是离散值来判断7.第一个机器学习算法是线性回归算法","categories":[],"tags":[]}],"categories":[],"tags":[]}